#!/usr/bin/python
# -*- coding: UTF-8 -*-
# this code is designed for finding the optimal escape route.

import math,random,os,shapefile,numpy
from osgeo import ogr
import geopandas as gpd
from geopandas import overlay
import pandas as pd

origin_shp="E:/#ned/optimal2/escape4_step0.shp"# take a empty shp to mark the point
def add_shp_field(shp_path, field_name):
    driver = ogr.GetDriverByName("ESRI Shapefile")
    source = driver.Open(shp_path,1)# 0: read only; 1, read and write
    layer = source.GetLayer()

    field_box = []
    layer_define = layer.GetLayerDefn()

    # get all shp field title/name
    for n in range(layer_define.GetFieldCount()):
        field_title = layer_define.GetFieldDefn(n)
        field_box.append(field_title.name)

    # add field "field_name"
    box=[field_name]
    for add_field_name in box:
        if add_field_name in field_box:
            print("#"+ add_field_name + "# already in field")
        else:
            angle_field = ogr.FieldDefn(add_field_name, ogr.OFTReal)
            angle_field.SetPrecision(8)
            layer.CreateField(angle_field)
            print("field " + add_field_name + " had been added")
source=None
add_shp_field(shp_path=origin_shp,
              field_name="mark")

source_add_value = ogr.Open(origin_shp,1)# 0: read only; 1, read and write
layer_add_value = source_add_value.GetLayer()

i = 0
for feature in layer_add_value:
    name_mark = feature.GetField("mark")
    feature.SetField("mark", str(i+1))

    layer_add_value.SetFeature(feature)
    i = i + 1
source_add_value=None

try:
    make_path_merge = "E:\\#ned\\optimal\\merge\\"
    os.mkdir(make_path_merge)

    make_path_merge = "E:\\#ned\\optimal\\#step\\"
    os.mkdir(make_path_merge)
except:
    print("folder merge already exists")

#notice, if the shp file storage path is too deep, there will be error "struct.error: unpack requires a buffer of 4 bytes"
def copy_shp (source_shp, copied_shp):
    shp_from_where = shapefile.Reader(source_shp)
    duplicated_shp = shapefile.Writer(copied_shp)

    duplicated_shp.fields = shp_from_where.fields[1:]

    for shape_rec in shp_from_where.iterShapeRecords():
        duplicated_shp.record(*shape_rec.record)
        duplicated_shp.shape(shape_rec.shape.__geo_interface__)
    duplicated_shp.close()


for cal_number in range (1,5):
    origin_shp="E:/#ned/optimal/escape"+str(cal_number)+"_step0.shp"
    copy_shp(source_shp="E:/#ned/optimal/mark_shp.shp",
             copied_shp="E:/#ned/optimal/merge/external"+str(cal_number)+"_step0.shp")

    copy_shp(source_shp=origin_shp,
             copied_shp="E:/#ned/optimal/#step/escape"+str(cal_number)+"_step0.shp")
# just find every potential route, then run Logical operating
time_step = 0
while time_step < 100:
    time_step = time_step + 1
    # Loop operation
    for cal_case in range (1,5):
        # copy the origin_shp, at this time the internal point is still exist
        from_copy_shp = "E:/#ned/optimal/#step/escape"+str(cal_case)+"_step"+str(time_step-1)+".shp"
        calculate_shp = "E:/#ned/optimal/#step/escape"+str(cal_case)+"_step"+str(time_step)+".shp"
        copy_shp(source_shp=from_copy_shp,
                 copied_shp=calculate_shp)

        find_mark_number=0
        destroy_box = []
        while find_mark_number < 4:
            find_mark_number = find_mark_number + 1
            mark_shp = "E:/#ned/optimal/merge/external"+str(find_mark_number)+"_step"+str(time_step-1)+".shp"

            # collect the destroy_mark point
            destroy_mark = gpd.read_file(mark_shp)
            destroy_mark_list = destroy_mark["mark"].tolist()
            destroy_box = destroy_mark_list
            destroy_mark.Destroy()

        set_destroy_box=set()
        for item in destroy_box:
            for i in item:
                set_destroy_box.add(i)
        counter_repeat=Counter(set_destroy_box)
        f = open("E:/#ned/counter_repeat.txt", 'a')
        f.write(str(destroy_box) + "\n")
        f.close()
        # delete the external point, that is the destroyed people
        delete_dead_point = gpd.read_file(calculate_shp)
        delete_Cursor = delete_dead_point["mark"].tolist()

        # try to delete the dead point
        try:
            for delete_number in delete_Cursor:
                if delete_number in destroy_box:
                    before_update = gpd.read_file(calculate_shp)
                    after_update = before_update.drop(before_update[before_update['mark'] == delete_number].index)
                    print("delete the " + str(delete_number))

                    after_update.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
        except:
            print("none destroyed people")

        del destroy_box[:]


        # prepare the shp layer and geometry
        move_point = ogr.Open(calculate_shp, 1)  # 0: read only; 1, read and write
        move_layer = move_point.GetLayer()
        layer_define = move_layer.GetLayerDefn()
        move_feature = move_layer.GetNextFeature()

        feature = ogr.Feature(layer_define)

        # create the multi-point data set
        faucets = ogr.Geometry(ogr.wkbMultiPoint)
        faucet = ogr.Geometry(ogr.wkbPoint)

        # determine how many points exist
        dead_point_exist = gpd.read_file(calculate_shp)
        mark_list = dead_point_exist["mark"].tolist()
        mark_list_size = len(mark_list)  # get the point number
        angle_list = dead_point_exist["angle"].tolist()


        # define the "update_coordinate" function to update coordinates
        def update_coordinate(x_offset, y_offset, geometry_number):
            # set a set to store point
            update_point = ogr.Geometry(ogr.wkbPoint)
            update_point.SetPoint(0, x_offset, y_offset)
            feature.SetGeometry(update_point)
            # match the original "mark" and "angle" field
            feature.SetField("mark", mark_list[geometry_number])
            feature.SetField("angle", angle_list[geometry_number])
            # create new point in shp, and delete the previous calculate step
            move_layer.CreateFeature(feature)
            move_layer.DeleteFeature(int(geometry_number))
            # the following code is to ensure that the above operation has been updated
            move_layer.SetFeature(feature)

        i = 0
        while i < mark_list_size:
            geom = move_feature.GetGeometryRef()
            # get the current step coordinate
            x = float(geom.GetX())
            y = float(geom.GetY())
            ### take coordinate offset as run direction and velocity, just take 1 route when you calculate
            ### remember to change the run velocity (3)
            ### the escape angle 16, 29, 61 represents the escape direction, and it was calculated manually.
            pai = math.pi / 180  # move_angle is just took for mathematical calculation
            run_velocity = 3
            # calculate the escape A
            if cal_case == 1:
                ### for route A
                if angle_list[i] < 0:  # -74=-90+16, see figure Figure 6
                    x_offset = x - math.cos(pai * 16) * run_velocity
                    y_offset = y + math.sin(pai * 16) * run_velocity
                    # call the "update_coordinate" function
                    update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                    # close the shp, avoid using too much memory
                    move_feature.Destroy()
                    move_feature = move_layer.GetNextFeature()
                    i = i + 1
                elif angle_list[i] > 0:  # 106=90+19, here take the trigonometric transformation manually
                    x_offset = x + math.cos(pai * 16) * run_velocity
                    y_offset = y - math.sin(pai * 16) * run_velocity
                    # call the "update_coordinate" function
                    update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                    # close the shp, avoid using too much memory
                    move_feature.Destroy()
                    move_feature = move_layer.GetNextFeature()
                    i = i + 1
                ### for route B
                # if angle_list[i] < 0:  # -119=-74-45, see figure Figure 6
                # x_offset = x - math.cos(pai * 29) * run_velocity
                # y_offset = y - math.sin(pai * 29) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                # elif angle_list[i] > 0:  # 151=90+16+45
                # x_offset = x + math.cos(pai * 61) * run_velocity
                # y_offset = y - math.sin(pai * 61) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                ### for route C
                # #for row in Cal_Cursor:#-164=-90-74
                # x_offset = x - math.cos(pai * 74) * run_velocity
                # y_offset = y - math.sin(pai * 74) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                ### for route D
                # get the "run_step"
                # read_run_step = gpd.read_file(calculate_shp)
                # run_step_list = dead_point_exist["run_step"].tolist()
                # if time_step <= run_step_list[i]:  # execution route A
                # to run A left
                # if angle_list[i] < 0:  # -74=-90+16, see figure Figure 6
                # x_offset = x - math.cos(pai * 16) * run_velocity
                # y_offset = y + math.sin(pai * 16) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                # elif angle_list[i] > 0:  # 106=90+19, here take the trigonometric transformation manually
                # x_offset = x + math.cos(pai * 16) * run_velocity
                # y_offset = y - math.sin(pai * 16) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                # else:  # execution route B
                # to run B left
                # if angle_list[i] < 0:  # -119=-74-45, see figure Figure 6
                # x_offset = x - math.cos(pai * 29) * run_velocity
                # y_offset = y - math.sin(pai * 29) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
                # to run B right
                # elif angle_list[i] > 0:  # 151=90+16+45
                # x_offset = x + math.cos(pai * 61) * run_velocity
                # y_offset = y - math.sin(pai * 61) * run_velocity
                # call the "update_coordinate" function
                # update_coordinate(x_offset=x_offset, y_offset=y_offset, geometry_number=i)
                # close the shp, avoid using too much memory
                # move_feature.Destroy()
                # move_feature = move_layer.GetNextFeature()
                # i = i + 1
            else:
                print("Error calculating coordinates")
        move_point.Destroy()


        # select the internal and external point
        cut_shp = "E:/#ned/optimal/boundary.shp"
        internal_shp = "E:/#ned/optimal/merge/internal"+str(cal_case)+"_step"+str(time_step)+".shp"
        external_shp = "E:/#ned/optimal/merge/external"+str(cal_case)+"_step"+str(time_step)+".shp"

        allow_override = True

        # read shp and set crs, then save to local
        calculated_point = gpd.read_file(calculate_shp)

        try:  # set the coordinate system, otherwise it cannot be calculated
            calculated_point = calculated_point.set_crs(epsg=2379)
        except:
            calculated_point = calculated_point.to_crs(epsg=2379)
        calculated_point.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
        # reload the point
        point_gpd = gpd.read_file(calculate_shp)
        # print(point_gpd.crs)

        # read shp and set crs, then save to local
        cut_mask = gpd.read_file(cut_shp)
        try:
            cut_mask = cut_mask.set_crs(epsg=2379)
        except:
            cut_mask = cut_mask.to_crs(epsg=2379)
        cut_mask.to_file(cut_shp, driver="ESRI Shapefile", encoding="utf-8")
        # reload the polygon
        mask_gpd = gpd.read_file(cut_shp)
        # print(mask_gpd.crs)

        # take "mask_gpd (landslide boundary)" to clip the calculated
        get_internal_shp = gpd.clip(point_gpd, mask_gpd)
        # to_file can not covert empty dataframe to shp
        if get_internal_shp.empty:
            copy_shp(source_shp="E:/#ned/store/internal_step0.shp",
                     copied_shp=internal_shp)
        else:
            get_internal_shp.to_file(internal_shp, driver="ESRI Shapefile", encoding="utf-8")
        # delete useless field
        try:
            df = gpd.read_file(internal_shp)
            delete_field_internal_shp = df.drop(["Name", "CID", "LowPS", "LowPS", "HighPS", "MaxPS", "Tag", "Category",
                                                 "GroupName", "CenterX", "CenterY", "ZOrder", "TypeID", "ItemTS",
                                                 "UriHash"], axis=1)
            delete_field_internal_shp.to_file(internal_shp)
            print(delete_field_internal_shp)
        except:
            print("delete noting fields")
        # take the external point, at time=x, the external+internal=calculated point
        # select the points that lie inside the boundary
        # when we take "overlay","sjoin", if the data set is too big, an error "single positional indexer is out-of-boundsâ€œ will appear
        # read shp and set crs, then save to local
        reload_internal_shp = gpd.read_file(internal_shp)
        try:
            reload_internal_shp = reload_internal_shp.set_crs(epsg=2379)
        except:
            reload_internal_shp = reload_internal_shp.to_crs(epsg=2379)
        reload_internal_shp.to_file(internal_shp, driver="ESRI Shapefile", encoding="utf-8")
        reload_internal_shp = gpd.read_file(internal_shp)

        SymDiff_analysis = gpd.overlay(point_gpd, reload_internal_shp, how="symmetric_difference")
        SymDiff_analysis.to_file(external_shp, driver="ESRI Shapefile", encoding="utf-8")
        if SymDiff_analysis.empty:
            copy_shp(source_shp="E:/#ned/#s_A/#step/step_" + str(time_step) + ".shp",
                     copied_shp=external_shp)
        else:
            SymDiff_analysis.to_file(external_shp, driver="ESRI Shapefile", encoding="utf-8")

        # statistic the survival human number
        internal_count_survival = gpd.read_file(internal_shp)
        count_number = internal_count_survival["angle"].tolist()  # you can take any field, except for Null value
        survivors_number = len(count_number)

        print("step_" + str(time_step) + " survivors number:" + str(count_number))

        # write the number of survivors
        txt_name="E:/#ned/optimal/survival_number_"+str(cal_case)+".txt"
        f = open(txt_name, 'a')
        f.write("cal"+str(cal_case)+"step_" + str(time_step) + " Survivors number:" + str(count_number) + "\n")
        f.close()


### the following code is designed for selecting the destroyed points (dead position),
### you'd better not use the following codes with previous step.

box_A=[]
box_B=[]
box_C=[]
box_D=[]
box_I=[]

mark_number=0
while mark_number<100:
    mark_number=mark_number+1

    mark_shp_A = "external1_step"+str(mark_number) + ".shp"
    mark_Cursor_A = gpd.read_file(mark_shp_A)
    box_A = mark_Cursor_A["mark"].tolist()
    mark_Cursor_A.Destroy()

    set_A = set()
    for item in box_A:
        for i in item:
            set_A.add(i)


    mark_shp_B = "external2_step"+str(mark_number) + ".shp"
    mark_Cursor_B = gpd.read_file(mark_shp_B)
    box_B = mark_Cursor_B["mark"].tolist()
    mark_Cursor_B.Destroy()

    set_B = set()
    for item in box_B:
        for i in item:
            set_B.add(i)


    mark_shp_C = "external3_step"+str(mark_number) + ".shp"
    mark_Cursor_C = gpd.read_file(mark_shp_C)
    box_C = mark_Cursor_C["mark"].tolist()
    mark_Cursor_C.Destroy()

    set_C = set()
    for item in box_C:
        for i in item:
            set_C.add(i)


    mark_shp_D = "external4_step"+str(mark_number) + ".shp"
    mark_Cursor_D = gpd.read_file(mark_shp_D)
    box_D = mark_Cursor_D["mark"].tolist()
    mark_Cursor_D.Destroy()

    set_D = set()
    for item in box_D:
        for i in item:
            set_D.add(i)

    # the following is Four Route
    box_I=list(set_A & set_B & set_C & set_D)

    # the following is No route
    # remember the #external# should be replace by #external,
    # and only consider mark_number=100
    #box_I=list(set_A & set_B & set_C & set_D)

    # the following is Only One route
    #box_E=list(set_A.union(set_B).union(set_C))
    #box_I=list(set_D-set(box_E))# eg. only route A

    # the following is Two Route
    #box_E=list(set_A.union(set_B))# eg. route A & B
    #box_G=list(set_C & set_D)
    #box_I=list(set(box_G)-set(box_E))

    # the following is Three Route
    #box_E=list(set_D & set_A & set_B)# eg. route A & B & C
    #box_I = list(set(box_E)-set_C)

print(box_I)
for x in box_I:
    f = open("E:/#ned/optimal/optimal_route/A+B+D.txt", 'a')
    f.write(str(x) + "\n")
    f.close()
try:
    del box_I[:]
except:
    print("step" + str(mark_number))

# output the point number and draw the figure

result = []
fd = file("E:/#ned/optimal/optimal_route/merge A.txt", "r")

for line in fd.readlines():
    result.append(list(line.strip('\n').split(',')))

destroy_box=[]
for item in result:
    for it in item:
        destroy_box.append(float(it))


def copy_shp (source_shp, copied_shp):
    shp_from_where = shapefile.Reader(source_shp)
    duplicated_shp = shapefile.Writer(copied_shp)

    duplicated_shp.fields = shp_from_where.fields[1:]

    for shape_rec in shp_from_where.iterShapeRecords():
        duplicated_shp.record(*shape_rec.record)
        duplicated_shp.shape(shape_rec.shape.__geo_interface__)
    duplicated_shp.close()
copy_shp(source_shp="E:/#ned/optimal/escape1_step0.shp",
         copied_shp="E:/#ned/optimal/permutation_combination_16/merge A.shp")

# delete the external point, that is the destroyed people
delete_dead_point = gpd.read_file(calculate_shp)
delete_Cursor = delete_dead_point["mark"].tolist()

# try to delete the dead point
try:
    for delete_number in delete_Cursor:
        if delete_number not in destroy_box:
            before_update = gpd.read_file(calculate_shp)
            after_update = before_update.drop(before_update[before_update['mark'] == delete_number].index)
            print("delete the " + str(delete_number))

            after_update.to_file(calculate_shp, driver="ESRI Shapefile", encoding="utf-8")
except:
    print("none destroyed people")